<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Web-based SimpleAnalysis HOWTO</title><link rel="stylesheet" href="e-novative.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.55.0"/><meta name="description" content="&#xA;	  This HOWTO tries to teach you to run a web based sequence&#xA;	  analysis program using basic SimpleAnalysis rules.&#xA;	"/></head><body><div xmlns="" id="customheader"><span class="logo"></span>
    
    </div><div class="article"><div class="titlepage"><div><h1 class="title"><a id="d3e1"/>Web-based SimpleAnalysis HOWTO</h1></div><div><div class="author"><h3 class="author">Richard Adams</h3><div class="affiliation"><span class="orgname">Dept. Medical Genetics, University of Edinburgh<br/></span><div class="address"><p><tt>&lt;<a href="mailto:radams_at_staffmail.ed.ac.uk">radams_at_staffmail.ed.ac.uk</a>&gt;</tt></p></div></div></div></div><div><div class="legalnotice"><p>This document is copyright Richard Adams, 2003.  It can
        be copied and distributed under the terms of the Perl
        Artistic License.
	</p></div></div><div><p class="pubdate">2003-11-14</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.1</td><td align="left">2003-11-14</td><td align="left">RA</td></tr><tr><td align="left" colspan="3">First version</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
	  This HOWTO tries to teach you to run a web based sequence
	  analysis program using basic SimpleAnalysis rules.
	</p></div></div><hr/></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt>1. <a href="#introduction">Introduction</a></dt><dt>2. <a href="#Simple">Simple Examples</a></dt><dt>3. <a href="#retrieving_results">Retrieving results</a></dt><dt>4. <a href="#Metasequences">Metasequences</a></dt><dt>5. <a href="#parameters">How to  run the same analysis with varying parameters</a></dt><dt>6. <a href="#caveats">Caveats</a></dt><dt>7. <a href="#developing">Interested in developing your own Analysis module?</a></dt><dt>8. <a href="#Acknowledgments">Acknowledgments</a></dt></dl></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="introduction"/>1. Introduction</h2></div></div><p>
        There are several situations where it would be useful to run a web
        based sequence analysis program via a Perl script rather than using
        the web interface manually or downloading the program. Firstly, the
        source code or binaries may be unavailable or unavailable on your
        platform. Secondly, the analysis may depend on a regularly updated or
        large database that you don't wish to store or keep updated
        yourself. Thirdly, novel analyses are frequently available via a web
        server before being available for download.
      </p><p>
        The aim of the Bio::Tools::Analysis modules is to allow automatic
        submission of sequences to prediction servers to facilitate sequence
        annotation for low to medium numbers of sequences (perhaps tens to
        hundreds). The modules both submit the sequences and parse the results
        into a number of useful formats, usually including Bio::SeqFeature
        objects, Bio::Seq::MetaI sequence objects and a basic Perl data
        structure, as well as the raw output text.
      </p><p>
        At present the following prediction servers are supported, mainly
        reflecting my own research interests. Under current development
        are modules wrapping remote analyses using HMMER, Pfam, the ELM 
        peptide motif database and SIFT for prediction of untolerated 
        non-synonymous SNPs. 
       <div class="table"><a id="d3e29"/><table summary="Supported analyses" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Analysis</th><th>Purpose</th><th>Reference</th></tr></thead><tbody><tr><td>Domcut</td><td>Protein domain boundaries</td><td>Bioinformatics 19, 673-674 (2003)</td></tr><tr><td>NetPhos</td><td>Protein phosphorylation sites</td><td>J Mol Biol 294, 1351-1362 (1999)</td></tr><tr><td>GOR4</td><td>Protein Secondary structure</td><td>Meths. Enzymology 266, 540-553 (1996)</td></tr><tr><td>HNN</td><td>Protein Secondary structure</td><td>Bioinformatics 15,413-421 (1999)</td></tr><tr><td>Sopma</td><td>Protein Secondary structure</td><td>Comput Appl Biosci 11, 681-684 (1995)</td></tr><tr><td>Mitoprot</td><td>Mitochondrial cleavage site prediction</td><td>Eur J Biochem 241, 779-786 (1996)</td></tr><tr><td>ESEfinder</td><td>Exonic splice site enhancers</td><td>NAR 31, 3568-3571 (2003)</td></tr></tbody></table><p class="title"><b>Table 1. Supported analyses</b></p></div>
      </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="Simple"/>2. Simple Examples</h2></div></div><p>
        The script below runs multiple analyses on a single sequence
        and parses the results into standard BioPerl sequence feature
        objects (Bio::SeqFeature::Generic objects to be precise). 
       <pre class="programlisting">
     # load up the modules
     
     use Bio::Tools::Analysis::Protein::HNN;
     use Bio::Tools::Analysis::Protein::Domcut;
     use Bio::Tools::Analysis::Protein::MitoProt;
     use Bio::Tools::Analysis::Protein::NetPhos;
     
     
     our @ISA = qw(Bio::Tools::Analysis::SimpleAnalysisBase);
     
     my $seq;# a Bio::Seq object
     for my $method ( qw(Domcut MitoProt NetPhos HNN)) {
     
        #analyses need a Bio::PrimarySeq, not a Bio::Seq;
        my $tool = Bio::Tools::Analysis::Protein::$method-&gt;new(
             -seq =&gt; $seq-&gt;primary_seq);
        $tool-&gt;run();
        my @fts = $tool-&gt;result('Bio::SeqFeatureI');
        $seq-&gt;add_SeqFeature(@fts);	
     }        
       </pre>
      </p><p>
        The above script runs several analyses using default parameters. All
        analyses have such defaults and  in general only a sequence of the 
        appropriate type is needed for the analysis to be submitted. A sequence
        can be added either in the constructor, as shown above, or by the seq()
        method. 
       <pre class="programlisting">
     my $primary_seq = new Bio::PrimarySeq(-seq=&gt;$seq_as_string);
     my $tool =  new Bio::Tools::Analysis::Protein::NetPhos(); 
     $tool-&gt;seq($primary_seq);
       </pre>
        Note that the only valid sequence format is a Bio::PrimarySeq object.
		 This is in order to support multiple methods of retrieving the 
        results. If you initially have  a Bio::Seq object or Bio::RichSeq
        object (e.g., from a GenBank file) you can call its primary_seq() 
        method to obtain a Bio::PrimarySeq object.
      </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="retrieving_results"/>3. Retrieving results</h2></div></div><p>
		If the run() method executes successfully, the raw output (stripped of
        HTML) is now stored in the Analysis object. 
        All modules should return the raw report by a call to result() 
        with no parameters. e.g., 
     <pre class="programlisting">
     my $raw_report = $tool-&gt;result();
     </pre>
        A second way is to retrieve a ready-parsed data structure:
    <pre class="programlisting">
     my $parsed_report = $tool-&gt;result('parsed'); 
    </pre>
        The data structure returned is described in the $RESULT_SPEC-&gt;{'raw'}
        hash reference and should always be a native Perl data structure.
   </p><p>
        A third way is to retrieve an array of sequence features:
    <pre class="programlisting">
     my @fts = $tool-&gt;result('Bio::SeqFeatureI'); 
     $seq-&gt;add_SeqFeature(@fts); # add features to sequence.
    </pre>

        These are Bio::SequenceFeature::Generic features. Sometimes a
        module might use some code to judge the significance of a
        result prior to listing it as a feature, for example in the
        secondary structure prediction modules.  The rules governing this
        are described in  individual modules. For example, I have put in a rule 
        that only runs of a minimum of 4 consecutive residues predicted to be
        beta sheet or alpha helix can be annotated as features - it makes no sense 
        for a single isolated residue to be annotated as being in a helix. 
		However you might want to filter the raw results yourself, in which 
        case retrieving the results as Bio::Seq::Meta::Array type objects 
        might be better. 

   </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="Metasequences"/>4. Metasequences</h2></div></div><p>

        Many analyses produce a list of scores, one for each residue
        in a sequence. For example, the protein secondary structure
        prediction program Sopma returns a list of probabilities for
        each residue being in helix, sheet, turn or coil. These
        modules make this data available in the form of meta
        sequences. These are sequence objects derived from
        Bio::PrimarySeq that have arrays of sequence associated data
        contained in the object. The meta sequence names should be
        listed in the individual module documentation.  To retrieve
        results like this supply the string 'meta' as a parameter
        to the result() method.
		Meta sequence objects can access all the PrimarySeq object 
        methods for accessing and manipulating the protein/DNA sequence
        and also have specific methods for accessing the result data. 

      <pre class="programlisting">
     $meta_seq = $analysis-&gt;result('meta');
      </pre>

        This returns a sequence object with the raw analysis data
        accessible through methods e.g.,

     <pre class="programlisting">
     my @scores1_20 = $meta_seq-&gt;named_sub_meta('Sopma_turn', 1,20);
     </pre>

        returns an array of scores for the first 20 amino acids

     <pre class="programlisting">
     my @allscores = $meta_seq-&gt;named_meta('Sopma_turn');
     </pre>

        returns an array of scores for the whole sequence. The names of 
        individual meta sequence names are listed in the module 
        documentation.
     </p><p>

       Although a full description of how metasequence objects work isn't
       really the purpose of this HOWTO there is excellent documentation in
       Bio::Seq::MetaI and Bio::Seq::Meta::Array modules. 
     </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="parameters"/>5. How to  run the same analysis with varying parameters</h2></div></div><p>

      You might want to run some analyses with varying parameters in
      order to determine the effect on the prediction.  
      At present only the Sopma module takes alternative parameters i.e.
      arguments other than just the sequence. Any parameter that is settable
      on the web form should have a method of the same name to get/set its
      values, or alternatively it can be set in the constructor.

      <pre class="programlisting">
     my $sopma = Bio::Tools::Analysis::Protein::Sopma-&gt;new();
     $sopma-&gt;seq(seqobj-&gt;primary_seq);
     $sopma-&gt;window_width(21);
     </pre>

     So, let's suppose we want to investigate how varying the window_width 
     parameter affects the secondary structure prediction for a sequence. 
     We can do this inthe following manner:
   
		
    <pre class="programlisting">
     my $seq = Bio::Seq-&gt;new(-seq =&gt; 'ASFATFDATFATFSTFATSFATFSTAF');
     my $tool = Bio::Tools::Analysis::Protein::Sopma-&gt;new
       (-seq=&gt;$seq-&gt;primary_seq);
     
     for my $w_size(qw(11 13 15 17 19 21 23)) {
     
         $tool-&gt;window_width($w_size);  #set new parameter
         $tool-&gt;run(); #default parameters
     
         #2nd param is appended to metasequence name
         $tool-&gt;result('meta', $w_size);
             
         ## add to sequence features
         $seq-&gt;add_SeqFeature(
         $tool-&gt;result('Bio::SeqFeatureI'));
         $tool-&gt;clear(); #removes raw data from the previous analysis
     }
     # meta seq now has 28 arrays of metadats - 7 analyses and
     # 4 prediction categories,
     
     ## now get meta_sequence
     my $meta_seq = $tool-&gt;seq();
    </pre>
        Only 3 new points are raised by this program. Firstly, each time
        the analysis is run it needs to be parsed immediately. The raw
        report data is removed from  one analysis to another to reduce
        memory usage. Secondly, in order to distinguish the meta data 
        each analysis needs to be given a specific identifier which is 
        appended to the default name. So in this case the meta data names 
        would be Sopma_meta|11, Sopma_meta|13, etc. 
        Thirdly, the  clear() method should be called between 
        analyses of the same sequence to ensure the internal data fields
        that hold the raw report are removed. So if you want to keep the raw 
        reports you need to store them after each analysis is returned.
   </p><p>

	    So, how are features obtained from multiple runs distinguished? 
	    This information is contained in tags with the same name as the
        parameters, when the settings aren't the default ones. In other words,
        the features retain knowledge of the analysis method's parameters. 
    
	<pre class="programlisting">                         
     ## carrying on from previous listing.... ##
     ##
     ## get all secondary structure features
     my @sec_fts = grep{$_-&gt;primary_tag eq '2ary'} 
                       $seq-&gt;all_SeqFeatures;
     my @ww11 = grep{($_-&gt;each_tag_value('method'))[0]  eq 'Sopma' &amp;&amp;
                     ($_-&gt;each_tag_value('window_width'))[0] == 11}
                     @sec_fts;
     
     ## now onto comparison..... ##
     </pre> 


     </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="caveats"/>6. Caveats</h2></div></div><p>

        The problem with these analyses is their speed of execution, which
        obviously depends on your network speed, the complexity of the
        analysis and the speed of the host. Moreover, it is usually polite to
        leave a second or two between requests to avoid blocking the server,
        which means that to annotate a single protein sequence with all of the
        X methods available may take over a minute. Certainly these modules
        are unsuitable for genome scale analysis and are designed for use with
        smaller numbers of sequences. However, the code in the result()
        methods should still be usable for parsing analyses run locally when
        the local output and webpage output are the same format.

      </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="developing"/>7. Interested in developing your own Analysis module?</h2></div></div><p>
        Most of the hard work is done by Bio::WebAgent and
        Bio::SimpleAnalysisBase. Any module must inherit from this latter
        module as it contains methods common to all analyses.
      </p><p>
        For a minimal prediction server which takes just sequence as a
        parameter (e.g., Domcut), only 3 methods need to be explicitly
        written.
      </p><p>
        1. _run() which mimics the web form, submits the sequence
        and extracts the raw text data of the result from the HTML.
      </p><p>
        2. result() which parses the raw data into whatever useful format you
        wish. Usually these include SeqFeature objects, standard Perl data
        structures and meta sequences if there is a result for each residue in
        the sequence.
      </p><p>
        3. _init() which imports the analysis specifications into the
        Analysis object
      </p><p>
        As well as these methods, various file scoped lexical hashes need to
        be defined which hold constant data about the analysis, and the
        analysis result. These are useful for reference and are incorporated
        into the analysis objects.
      </p><p>
        
        For more complicated prediction programs with analysis specific
        parameters (e.g., Sopma), get/set methods need to be written. Also, if
        any of these parameters need special error checking then a
        check_parameters() needs to be written as well. The nature of these
        parameters should be listed in a hash referenced by the $INPUT_SPEC
        variable.

      </p><p>
        Alternatively, mail me with your suggestion and I'll try to put one
        together.  It is my intent to keep the modules up to date with new 
        analysis programs as they become available which are not included in
        the usual protein annotations and will be glad to hear of new 
        suggestions.
      </p></div><div class="section"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="Acknowledgments"/>8. Acknowledgments</h2></div></div><p>
      These modules depend on several recently developed modules and wouldn't
      work at all without them: Bio::Seq::Meta modules by
      Chad Matsalla, Aaron Mackey and Heikki Lehvaslaiho,
      Bio::WebAgent by
      Heikki Lehvaslaiho, and 
      Bio::SimpleAnalysisI by
      Martin Senger.
    </p></div></div><div xmlns="" id="customfooter">
      
      
      
    </div></body></html>