<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "./docbookx.dtd"
  [ <!ENTITY % global.entities SYSTEM "./global.xml">
    %global.entities;

    <!ENTITY % entities SYSTEM "./entities.xml">
    %entities; ]
>
 <article lang="en"> 
   <articleinfo>
     <title>Population Genetics in BioPerl HOWTO</title>
     <author>
       <firstname>Jason</firstname>
       <surname>Stajich</surname>
       <authorblurb>
	 <para>Bioperl Core Developer</para>
       </authorblurb>
       <affiliation>
	 <orgname>Dept Molecular Genetics and Microbiology, Duke
	 University</orgname>
	 <address><email>jason-at-bioperl-dot-org</email></address>
       </affiliation>
      </author>
    <pubdate>2004-06-21</pubdate>
    <revhistory>
      <revision>
	<revnumber>0.1</revnumber>
	<date>2004-06-28</date>
	<authorinitials>JES</authorinitials>
	<revremark>First draft</revremark>
      </revision>
    </revhistory>
    <legalnotice>
      
      <para>This document is copyright Jason Stajich, 2004.  It can be
	copied and distributed under the terms of the Perl Artistic
	License.</para>
    </legalnotice>
      
   </articleinfo>

 <section id="intoduction">
  <title>Introduction</title>
  <para>
   We have aimed to build a set of modules
   that can be used as part of an automated process for testing
   population genetics and molecular evolutionary hypotheses.  These
   typically center around sequence based data and we have built a
   set of routines which will enable processing of large datasets in a
   pipeline fashion.

  </para>
  <para>
    This document will be split up into sections which describe 
    the data objects for representing populations, tests you can
    perform using these objects, a coalescent implementation,
    and objects for performing sequence distance based calculations.
    A full treatment of the Bioperl interface to the PAML suite
    (Z.Yang, 1997) is covered in the PAML HOWTO and objects and data
    pertinent to phylogenetic data manipulation are covered in the
    Trees HOWTO.
  </para>
 </section>
 <section id="basicobjects">
   <title>The Bio::PopGen Objects</title>
  <para>
    In Bioperl we have created a few objects to describe population
    genetic data.  These are all located in the Bio::PopGen
    namespace, so they can be browsed by looking at the Bio/PopGen
    directory.
  </para>
  <para>
    Bio::PopGen::Population is a container for a set of
    Bio::PopGen::Individual in order to represent individuals from a
    population.  Each Individual has a set of Bio::PopGen::Genotype
    genotype objects which are an allele set associated with a unique
    marker name.  Methods associated with the Population object can
    calculate the summary statistics such as pi, theta, heterozygocity
    by processing each Individual in the set .
  </para>
  <para>
    A Marker is the name given to a polymorphic region
    of the genome.  In some instances a Marker can be a unique
    collection of primer pair(s).  In other cases it be a set of
    restriction enzymes.  Markers are represented
    by a Bio::PopGen::Marker object which can contain information such
    as allele frequencies in a population.  Derived subclasses of the main
    Bio::PopGen::Marker are used to store specialized information
    about markers where supported by data formats.  This is done
    particularly in the Bio::Pedigree objects which are a
    set of modules derived from Bio::PopGen and intended to handle the
    case of interrelated individuals.
  </para>
 </section>
 <section id="buildingpops">
   <title>Building Populations</title>
  <para>
    Although a typical user will want to obtain data for analysis
    from files or directly from databases we will describe briefly
    how to create Individuals with Genotypes and Populations of
    Individuals directly in the code to illustrate the parameters
    used and access to the data stored in the objects.
  </para>
  <para>
    A genotype is a triple of a marker name (string), an individual id
    (string or int), and set of alleles (array of string).  The
    individual_id field is optional as it is explicitly set when a
    genotype is added to and individual.  We can
    instantiate a Genotype object by using the following code.  
  </para>
  
  <programlisting>
    use Bio::PopGen::Genotype;
    my $genotype = Bio::PopGen::Genotype->new(-marker_name   => 'D7S123',
                                              -individual_id => '1001',
                                              -alleles       => ['104','107'], 
                                              );
  </programlisting>
  <para>
    To get the alleles back out from a Genotype object the
    <programlisting>get_Alleles</programlisting> method can be used.  
    To replace alleles one must call
    the <programlisting>reset_Alleles</programlisting> and
    then <programlisting>add_Allele</programlisting> with a list of
    alleles to add for the genotype.
  </para>

  <para>
    This genotype object can be added to an individual object with the
    following code which also builds an individual with an id of
    '1001'.
  </para>
  <programlisting>
    use Bio::PopGen::Individual;
    my $ind = Bio::PopGen::Individual->new(-unique_id  => '1001',
                                           -genotypes  => [$genotype]
                                           );
  </programlisting>
   <para>
     There is no restriction on the names of markers nor is there any 
     attempted validation that a genotype's individual_id is equal to
     the id of Individual is has been associated with it.  It is
     merely a convience as it is 
    
   </para>
   <para>
    Additional genotypes can be added to an individual with the
    add_Genotype method as the following code illustrates. 
   </para>
   <programlisting>
     $ind->add_Genotype(Bio::PopGen::Genotype->new(
                         -alleles       => ['102', '123'],
                         -marker_name   => 'D17S111')
                        );
   </programlisting>
   <para>
     A population is a collecion of individuals and can be
     instantiated with all the individuals at once or individuals can
     be added to the object after it has been created. 
   </para>
   <programlisting>
     use Bio::PopGen::Population;
     my $pop = Bio::PopGen::Population->new(-name        => 'pop name',
                                            -description => 'description',
                                            -individuals => [$ind] );
     # add another individual later on
     $pop->add_Inidividual($ind2);
   </programlisting>
   <para>
     Using these basic operations one can create a population
     individuals.  Bio::PopGen::Marker objects are intended to provide
     summary of information about the markers stored for all the
     individuals.  
   </para>
   <para>
     Typically it is expected that all individuals will have a
     genotype associated for all the possible markers in the
     population.  For cases where no genotype information is available
     for an individual empty or blank alleles can be stored.  This is
     necessary for consistency when running some tests on the
     population but these blank alleles do not get counted when
     evaluating the number of alleles, etc.  Blank alleles can be
     coded as a dash ('-'), as a blank or empty (' ', or ''), or as
     missing '?'. The 'N' allele is also considered a blank allele.
     The regexp used to test if an allele is blank is stored in the
     Bio::PopGen::Genotype as the package variable $BlankAlleles.
     The following code resets the blank allele pattern to
     additionally match '.' as a blank allele.  This code should go
     BEFORE any code that calls the get_Alleles method in 
     Bio::PopGen::Genotype;
   </para>
   <programlisting>
     use Bio::PopGen::Genotype;
     $Bio::PopGen::Genotype::BlankAlleles = '[\s\-N\?\.]';
   </programlisting>
   <para>
     Bio::PopGen::Marker object... 
   </para>
 </section>    

 <section id="popgenio">
   <title>Reading and Writing Population data with Bio::PopGen::IO</title>
   <para>
     Typically one wants to get population data from a datafile. 
   </para>
   <para>
     To read data in CSV format
   </para>
   <para>
     The CSV format is a comma delimited format where each row is for
     an individual. The first column gives the individual or sample id
     and the rest of the columns are the alleles for the individual
     for each marker.  The names of the markers in these rows are
     listed in the header or which is the very first line of the file.
   </para>
   <programlisting>
     SAMPLE,D17S1111,D7S123
     1001,102 123,104 107
     1002,105 123,104 111
   </programlisting>
   <para>
     To read in this CSV we use the Bio::Popgen::IO object and specify
     the csv format.  We can
     call <programlisting>next_individual</programlisting> repeated
     times to get back a list of the individuals (one is returned
     after each time the iterator is called).  Additionally
     the <programlisting>next_population</programlisting> is a
     convience method which will read in all the individuals at once
     and create a new Bio::PopGen::Population object containing all
     of thse individuals.  The CSV format assumes that ',' is the
     delimiter between columns while '\s+' is the delimiter between
     alleles.  One can override these settings by providing the 
     -field_delimiter and -allele_delimited argument to 
     Bio::Popgen::IO when instantiating.  Additionally a flag called
     -no_header can be supplied which specifies there is no header
     line in the report and that the object should assign arbitrary
     marker names in the form 'Marker1', 'Marker2' ... etc.  
   </para>
   <para>
     Pretty Base format
   </para>
   <para>
     Phase and hapmap format
   </para>
   
 </section>
 <section id="statistics">
   <title>Summary Statistics with Bio::PopGen::Statistics</title>
   <para>
     pi
   </para>
   <para>
     theta
   </para>
   <para>
     Tajima's D
   </para>
   <para>
     Fu and Li's D, Fu and Li's D*
   </para>
   <para>
     Fu and Li's F, Fu and Li's F*
   </para>
   <para>
     Linkage Disequilibrium
   </para>

 </section>
 <section id="popstats">
   <title>Population Statistics</title>
   <para>
     Fst.
   </para>
 </section>
 <section id="coalescent">
   <title>Coalescent Simulations</title>
   <para>
     This module
   </para>
   <para>
     Example usage -- Heterogenetity test.
   </para>
 </section>

 </article>
