<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "./docbookx.dtd"
  [ <!ENTITY % global.entities SYSTEM "./global.xml">
    %global.entities;

    <!ENTITY % entities SYSTEM "./entities.xml">
    %entities; ]
>

<article lang="en">
  <articleinfo>
    <title>Beginners HOWTO</title>
    <author>
      <!-- 
		one of (CONTRIB AUTHORBLURB AFFILIATION OTHERNAME 
		LINEAGE SURNAME FIRSTNAME HONORIFIC) 
		-->
      <firstname>Brian</firstname>
      <surname>Osborne</surname>
      <authorblurb>
		  <para>Bioperl contributor</para>
      </authorblurb>
      <affiliation>
		  <orgname>
			 <ulink url="http://www.cognia.com">Cognia
				Corporation</ulink>
		  </orgname>
		  <address>
			 <email>brian-at-cognia.com</email>
        </address>
      </affiliation>
    </author>
    <author>
      <firstname>James</firstname>
      <surname>Thompson</surname>
      <authorblurb>
		  <para></para>
      </authorblurb>
      <affiliation>
		  <orgname>
			 <ulink url=""></ulink>
		  </orgname>
		  <address>
			 <email>tex-at-biocompute.net</email>
        </address>
      </affiliation>
    </author>

    <pubdate>2004-12-14</pubdate>
<!--
    <revhistory>
      <revision>
		  <revnumber></revnumber>
		  <date></date>
		  <authorinitials></authorinitials>
		  <revremark></revremark>
      </revision>
    </revhistory>
-->    
	 <legalnotice>
      <para>
		  This document is copyright Brian Osborne, 2004.  For
		  reproduction other than personal use please contact 
		  brian at cognia.com.
      </para>      
    </legalnotice>
    
    <abstract>
      <para>
		  This is a HOWTO written in DocBook (XML) that talks about using
		  Bioperl, for biologists who would like to learn more
		  about writing their own bioinformatics scripts using Bioperl. 
      </para>
    </abstract>
  </articleinfo>
  
  <section id="introduction">
    <title>Introduction</title>
    <para>
		If you're a molecular biologist it's likely that
		you're interested in gene and protein sequences, and you study them
		in some way on a regular basis. Perhaps you'd like to try your
		hand at automating some of these tasks, or you're just curious
		about learning more about the programming side of bioinformatics.
		In this HOWTO you'll see discussions of some of the common uses
		of Bioperl, 
		like sequence analysis with BLAST, retrieving sequences from 
		public databases, and making alignments. You'll also see how to
		write Bioperl scripts that chain these tasks together, that's
		how you'll be able to do really powerful things with Bioperl.
    </para>
    <para>
		You will also see some discussions of software concepts, this
		can't be avoided. The more you understand about
		programming the better but all efforts will be made
		to not introduce too much unfamiliar material. 
		However, there will be an introducton to modularity, or objects. This is 
		one of the aspects of the Bioperl package that you'll have
		to come to grips with as you attempt more complex tasks with
		your scripts.
    </para>
	 <para>
		One of the challenging aspects of learning a new skill is
		learning the jargon, and programming certainly has its share of
		interesting terms and concepts. Be patient - remember that the
		programmers learning biology have had just as tough a task
		(if not worse - just ask them!).
	 </para>
    <note>
      <para>
		  This HOWTO does not discuss a very nice module that's designed for
		  beginners, 
		  <ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Perl.html">Bio::Perl</ulink>. The reason is that though this is an
			 excellent introductory tool, it can't be extended. What we're
		  attempting here is to introduce Bioperl and show you
		  ways to expand your new-found skills.
      </para>
    </note>
  </section>

  <section id="installation">
    <title>Installing Bioperl</title>
    <para>
		The first thing to determine is the Bioperl platform - Unix or
		Windows? Here are some things to consider, if you're choosing 
		between the two.
	 </para>
	 <para>
		<emphasis>Unix Advantages</emphasis>
		<simplelist type="horiz" columns="1">
		  <member>
			 Knowing some Unix is a useful skill. No matter how prevalent 
			 Windows is on the desktop, Unix rules bioinformatics.
		  </member>
		  <member>
			 Unix isn't as hard as you may think, if you know less than
			 10 commands you're ready to work.
		  </member>
		  <member>
			 Every bioinformatics application you've ever heard of runs on Unix.
		  </member>
		  <member>
			 If you want to do serious computation the typical Unix server is
			 probably more stable and more powerful than the 
			 available Windows machine.
		  </member>
		  <member>
			 There's an administrator taking care of the machine - maybe
			 she'll even install Bioperl for you! Ask and see.
		  </member>
		</simplelist>
	 </para>
	 <para>
		<emphasis>Unix Disadvantages</emphasis>
		<simplelist type="horiz" columns="1">
		  <member>
			 The command-line can seem unfamiliar and awkward at first.
		  </member>
		  <member>
			 Your Unix account may be on a server - not too portable!
		  </member>
		  <member>
			 You won't have easy access to all your familiar programs.
		  </member>
		  <member>
			 You'll probably have to learn to use a Unix word processor,
			 like emacs or vi.
		  </member>
		  <member>
			 You won't have control of the machine, the administrator
			 will. You may not be able to download all of Genbank,
			 for example!
		  </member>
		</simplelist>
	 </para>
	 <para>
		<emphasis>Windows Advantages</emphasis>
		<simplelist type="horiz" columns="1">
		  <member>
			 Simplicity, if Windows is what you're working with now.
		  </member>
		  <member>
			 Plenty of Bioperl users run it on Windows.
		  </member>
		</simplelist>
	 </para>
	 <para>
		<emphasis>Windows Disdvantages</emphasis>
		<simplelist type="horiz" columns="1">
		  <member>
			 Not all bioinformatics applications run on Windows.
		  </member>
		  <member>
			 It's your computer, you will have to deal with the installation details
			 yourself.
		  </member>
		  <member>
			 Your computer may not be able to handle serious computation gracefully.
		  </member>
		</simplelist>
	 </para>
    <para>
		The instructions for Unix and Windows installations are found
		on the 
		<ulink url="http://bioperl.org/Core/Latest/index.shtml">download page</ulink>.
		If you do run into problems then mail bioperl-l@bioperl.org,
		this is the main mailing list, and installation issues are
		discussed frequently.
	 </para>
	 <tip>
		<para>
		  If you decide to use Unix there are many Web pages that can 
		  give you a good introduction, google "introduction unix" to
		  see more than a few.
		</para>
	 </tip>
  </section>
  
  <section id="help">
    <title>Getting Assistance</title>
    <para>
		People will run into problems installing Bioperl or writing 
		scripts using Bioperl, nothing unusual about that. If you need 
		assistance the way to get it is to mail bioperl-l@bioperl.org.
		There are a good number of helpful people who regularly read
		this list but if you want their advice it's best to give
		sufficent detail.
	 </para>
	 <para>
		<emphasis>Please include:</emphasis>
		<simplelist type="horiz" columns="1">
		  <member>
			 The version of Bioperl you're working with. 
		  </member>
		  <member>
			 The platform or operating system you're using. 
			 </member>
		  <member>
			 What you are trying to do.
		  </member>
		  <member>
			 The code that gives the error, if you're writing a script.
		  </member>
		  <member>
			 Any error messages you saw.
		  </member>
		</simplelist>
    </para>    
    <para>
		Every once in a while a message will appear in bioperl-l 
		coming from someone
		in distress that goes unanswered. The explanation is simple,
		the person neglected to include 1 or more of the details above,
		usually the script or the error messages. If you give enough 
		information you will get help.
    </para>
  </section>

  <section id="perl">
    <title>Perl Itself</title>
    <para>
		Here are a few things you might want to look at if you
		want to learn about Perl itself:
	 </para>
    <para>
		<simplelist type="horiz" columns="2">
		  <member>
			 Perl's own documentation. Do "perldoc perl" from the
			 command-line for an introduction.
		  </member>
		  <member>
			 <ulink url="">Learning Perl</ulink>
			 is the most frequently cited beginner's book.
		  </member>
		  <member>
			 <ulink url="">Perl in a Nutshell</ulink>
			 is also good. Not much in the way of examples, but covers
			 many topics succintly.
		  </member>
		  <member>
		  </member>
		</simplelist>
    </para>
    <para>
    </para>
    <para>
    </para>
    <para>
      <programlisting>
      </programlisting>
    </para>
  </section>

  <section id="starting_unix">
	 <title>Starting to write a script on Unix</title>
	 <para>
		Sometimes the trickiest part is this step, writing something and
		getting it to run. Windows and Unix are slightly different, let's
		address them separately.
	 </para>
	 <para>
		In Unix when you're ready to work you're usually in the
		command-line or "shell" environment. People have their own
		choices as to shell, usually bash or tcsh, sometimes zsh, csh,
		and so on. First find out Perl's version by typing this command:
	 </para>		
	 <para>
		<programlisting>
		  >perl -v
		</programlisting>
	 </para>
	 <para>
		You will see something like:
	 </para>
	 <para>
		<programlisting>
This is perl, v5.8.2 built for cygwin-thread-multi-64int

Copyright 1987-2003, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using `man perl' or `perldoc perl'.  If you have access to the
Internet, point your browser at http://www.perl.com/, the Perl Home Page.
		</programlisting>
	 </para>
	 <para>
		Hopefully you're using Perl version 5.4 or higher, earlier
		versions may be troublesome. Now let's find out where the Perl 
		program is located:
	 </para>	
	 <para>
		<programlisting>
			 >which perl
		</programlisting>
	 </para>
	 <para>
		This will give you something like:
	 </para>
	 <para>
		<programlisting>
		  >/bin/perl
		</programlisting>
	 </para>
	 <para>
		Now that we know where Perl is located we're ready to write a
		script, and line 1 of the script will specify this location.
		You're probably using some Unix word processor, emacs or vi,
		for example  (nano or pico are other possible choices,
		very easy to use, but not found on all Unix machines unfortunately).
		Start to write your script by entering something like:
	 </para>
	 <para>
		<programlisting>
		  >emacs seqio.pl
		</programlisting>
	 </para>
	 <para>
	 And make this the first line of the script:
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w
		</programlisting>
	 </para>
	 <para>
		The "-w" flag tells Perl to warn you if and when various common errors
		are encountered, it's useful.
	 </para>
  </section>

  <section id="create">
	 <title>Creating a sequence, and an object</title>
    <para>
		Our first script will create a sequence. In the process of
		creating a sequence you will also be creating an "object", since
		Bioperl is written in an object-oriented way. Why be
		object-oriented? Why introduce these novel or intrusive notions into
		software that should be "biological" or "intuitive"? The reason is 
		that thinking in terms of modules or objects turns out to be the
		most flexible, and ultimately the simplest, way to deal with
		data as complex as biological data. Once you get over your initial
		skepticism, and have written a few scripts, you will find this
		idea of an object becoming a bit more natural.
	 </para>
	 <para>
		One way to think about an object in software is that it is a container
		for data. The typical sequence entry contains
		differents sorts of data (a sequence, one or more identifiers, etc.)
		so it will serve as a nice example of what
		an object can be. All objects in Bioperl are created by specific
		Bioperl modules, so if you want to create an object you're also going
		to have to tell Perl which module to use. Let's add another line:
    </para>	
    <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::Seq;
		</programlisting>
    </para>
	 <para>
		This line says that there's a module file on your machine called
		"Bio/Seq.pm".
		We will "use" this 
		<ulink
		url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html">Bio::Seq</ulink>
		module to create a 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink> object.
		The 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink> module is one of the central modules in
		Bioperl. The analogous 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink> object, or "Sequence object", or
		"Seq object", is ubiquitous in Bioperl, it contains 
		a single sequence and associated names, identifiers, and
		properties. Let's create a very simple sequence object at
		first, like so:
    </para>
    <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::Seq;
		
		  $seq_obj = Bio::Seq->new(-seq => "aaaatgggggggggggccccgtt");
		</programlisting>
    </para>
	 <para>
		That's it! The variable <varname>$seq_obj</varname> is the
		Sequence object, a simple one, containing just a sequence.
	 </para>
	 <para>
      <note>
		  <para>
			 <ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink> objects can be created manually, as above, but
			 they're also create automatically in many operations
			 in Bioperl, for example when alignment files or
			 BLAST reports are parsed.
		  </para>
      </note>
	 </para>
	 <para>
		Any time you explicitly create an object, you
		will use this <function>new()</function> method. The syntax of this
		line is one you'll see again and again in Bioperl: the name
		of the object or variable, the module name, the
		string <emphasis>new</emphasis>, some argument name like
		<emphasis>-seq</emphasis>, the <emphasis>=></emphasis>, and then
		the argument or value itself, like
		<emphasis>aaaatgggggggggggccccgtt</emphasis>.
	 </para>
	 <para>
		<note>
		  <para>
			 If you've programmed before you've probably come across the term
			 "function". In object-oriented programming the term
			 "method" is used instead.			 
		  </para>
		</note>
	 </para>
	 <para>
		The object was described as a data container, but it is more
		than that. It can also do work, it can call
		specific methods taken from the module or modules that were used
		to create it. For example, the 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink>
		module has a method
		called <function>seq()</function> that will print out the
		sequence of 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink> objects. You could use it like this:
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::Seq;
		
		  $seq_obj = Bio::Seq->new(-seq => "aaaatgggggggggggccccgtt");

		  print $seq_obj->seq;
		</programlisting>
	 </para>
	 <para>
		As you'd expect, this script will print out <emphasis>
		  aaaatgggggggggggccccgtt</emphasis>. That <emphasis>->
		</emphasis> symbol is used when an object calls or accesses
		its methods. 
	 </para>
	 <para>
		Let's make our example a bit more true-to-life, since a typical
		sequence needs a name, perhaps a description, in addition to
		its sequence.
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::Seq;
		
		  $seq_obj = Bio::Seq->new(-seq => "aaaatgggggggggggccccgtt",
		                           -display_id => "#12345",
		                           -desc => "example 1" );

		  print $seq_obj->seq();
		</programlisting>
	 </para>
	 <para>
		"aaaatgggggggggggccccgtt", "#12345", and "example 1" are called
		"arguments" in programming jargon. You could say that
		this example shows how to pass arguments to the
		<function>new</function> method.
	 </para>
  </section>

  <section id="writing">
    <title>Writing a sequence to a file</title>
	 <para>
		This next example will show how two objects can work together
		to create a sequence file.
		We already have a sequence object, <varname>$seq_obj</varname>, 
		and we will create an
		additional object whose responsibility it is to read from and write
		to files. This object is the 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/SeqIO.html>Bio::SeqIO</ulink> object, 
		where IO stands for 
		<emphasis>I</emphasis>nput-<emphasis>O</emphasis>utput.
		By using 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/SeqIO.html>Bio::SeqIO</ulink> in this manner you will be able to get input
		and output from all of the sequence file formats supported by Bioperl
		(the <ulink url="http://bioperl.org/HOWTOs/SeqIO/index.html">
		  SeqIO HOWTO</ulink> has a complete list of supported formats).
		The way you create <classname>Bio::SeqIO</classname> objects is 
		very similar to the way we used <function>new()</function> to
		create a 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/Seq.html>Bio::Seq</ulink>, or sequence, object:
	 </para>    
	 <para>
		<programlisting>
		  use Bio::SeqIO;

		  $seqio_obj = Bio::SeqIO->new(-file => '>sequence.fasta', 
		                               -format => 'fasta' );
		</programlisting> 
	 </para> 
	 <para>
	   Note that <emphasis>&gt;</emphasis> in the -file argument.
		This character indicates that we're going to
		<emphasis>write</emphasis> to the file named
		"sequence.fasta", the same character we'd use if we were using Perl's
		<function>open()</function> function to write to a file. The
		"-format" argument, "fasta", tells the SeqIO object that it
		should create the file in fasta format.
    </para>
    <para>
		Let's put our 2 examples together:
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::Seq;
		  use Bio::SeqIO;

		  $seq_obj = Bio::Seq->new(-seq => "aaaatgggggggggggccccgtt",
		                           -display_id => "#12345",
		                           -desc => "example 1" );

		  $seqio_obj = Bio::SeqIO->new(-file => '>sequence.fasta', 
		                               -format => 'fasta' );

		  $seqio_obj->write_seq($seq_obj);
		</programlisting> 
	 </para> 
	 <para>
		Let's consider that last line, since this is where some  
		neophytes start to get a bit nervous. What does it mean? In that
		line we handed or passed the Sequence object to the SeqIO object as an
		argument to its <function>write_seq</function> method. Another
		way to think about this is that the SeqIO object understands how
		to take information from the Sequence object and write to a file
		using that information, in this case in fasta format. If you
		run this script like this:
	 </para>
	 <para>
		<programlisting>
>perl seqio.pl
		</programlisting>
	 </para>
	 <para>
		You should create a file called "sequence.fasta" that looks like
		this:
	 </para>
	 <para>
		<programlisting>
>#12345 example 1
aaaatgggggggggggccccgtt
		</programlisting>
	 </para>
	 <para>
		Let's demonstrate the intelligence of the SeqIO object - the example
		below shows what file content is created when "-format" is set to
		"genbank" instead of "fasta":
	 </para>
	 <para>
		<programlisting>
LOCUS       #12345                    23 bp    dna     linear   UNK
DEFINITION  example 1
ACCESSION   unknown
FEATURES             Location/Qualifiers
BASE COUNT        4 a      4 c     12 g      3 t
ORIGIN
        1 aaaatggggg ggggggcccc gtt
//
		</programlisting>
	 </para>
  </section>

  <section id="reading">
	 <title>Retrieving a sequence from a file</title>
	 <para>
		A common beginner's mistake is to not use
		<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/SeqIO.html">Bio::SeqIO</ulink> when working with sequence
		files. This is understandable in some respects. You
		may have read about Perl's <function>open</function>
		function, and Bioperl's way of retrieving sequences may look odd
		and overly complicated, at first. But don't use
		<function>open</function>! Using <function>open</function> 
		immediately forces you to do the parsing of the sequence
		file and this can get complicated very quickly. Trust
		the SeqIO object, it's built to open and parse all
		the common sequence formats, it can read and write to files,
		and it's built to operate with all the other Bioperl 
		modules that you will want to use. 
	 </para>
	 <para>
		Let's read the file we created previously, "sequence.fasta",
		using SeqIO. The syntax will look familiar:
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::SeqIO;

		  $seqio_obj = Bio::SeqIO->new(-file => "sequence.fa",
                                     -format => "fasta" );
		</programlisting>
	 </para>
	 <para>
		One difference is immediately apparent: there is no <emphasis>
		  &gt;</emphasis> character. Just as with with the <function>
		  open()</function> function this means we'll be reading from
		the "sequence.fasta" file. Let's add the key line, where
		we actually retrieve the Sequence object from the file:
	 </para>
	 <para>
		<programlisting>
		  #!/bin/perl -w

		  use Bio::SeqIO;

		  $seqio_obj = Bio::SeqIO->new(-file => "sequence.fa",
                                     -format => "fasta" );
		  
		  $seq_obj = $seqio->next_seq;
		</programlisting>
	 </para>
	 <para>
		Here we've used the <function>next_seq()</function> method of the
		<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/SeqIO.html">Bio::SeqIO</ulink> object. When you use, or call, 
		<function>next_seq()</function> the
		SeqIO	object will get the next available sequence, in this case
		the first sequence in the file that was just opened. The
		Sequence object, <varname>$seq_obj</varname>, that's created
		will be identical to
		to the Sequence object we created manually in our first example.
	 </para>
	 <para>
		If there were multiple sequences in the file you could just 
		continue to call <function>next_seq()</function> in some loop, 
		and SeqIO would retrieve the Seq objects, one by one, 
		until none were left:
	 </para>
	 <para>
		<programlisting>
		  while ($seq_obj = $seqio->next_seq){
		      # print the sequence
		      print $seq_obj->seq,"\n";
		  }
		</programlisting>
	 </para>
	 <para>
		Do you have to supply a "-format" argument when you are reading 
		from a file, as we did? Not necessarily, but it's the safe thing
		to do. If you don't give a format then the SeqIO object will 
		try to determine the format from the file suffix or extension 
		(and a list of the file extensions is in the  
		<ulink url="http://bioperl.org/HOWTOs/SeqIO/index.html">
		  SeqIO HOWTO</ulink>). In fact, the suffix "fa" is one that
		SeqIO understands, "-format" is unnecessary. Without a known
		suffix SeqIO will 
		attempt to guess the format based on the file's contents.
	 </para>
  </section>

  <section id="retrieving_gb">
	 <title>Retrieving a sequence from a remote database</title>
	 <para>
		One of the strengths of Bioperl is that it allows you to retrieve
		sequences from all sorts of sources, files, remote databases,
		local databases, regardless of their format. Let's use this 
		capability to get a entry from Genbank. What will we retrieve?
		Again, a Sequence object. Let's choose our module:
	 </para>
	 <para>
		<programlisting>
		  use Bio::DB::GenBank;
		</programlisting>
	 </para>
	 <para>
		We could also query SwissProt, GenPept, EMBL, or RefSeq in an 
		analogous fashion (e.g "use Bio::DB::SwissProt"). Now we'll
		create the object:
	 </para>
	 <para>
		<programlisting>
		  use Bio::DB::GenBank;

		  $db_obj = Bio::DB::GenBank->new;
		</programlisting>
	 </para>
	 <para>
		In this case we've created an object using the 
		<function>new</function> method but without arguments. 
		In fact, when creating this sort of database object no arguments or
		options are possible. Let's ask the object to do something
		useful:
	 </para>
	 <para>
		<programlisting>
		  use Bio::DB::GenBank;

		  $db_obj = Bio::DB::GenBank->new;
		  $seq_obj = $db_obj->get_Seq_by_id(2); 
		</programlisting>
	 </para>
	 <para>
		The argument passed to the <function>get_Seq_by_id</function>
		method is an identifier, 2, a Genbank GI number. You could
		also use the <function>get_Seq_by_acc</function> method, this
		would accept an accession number, "A12345" for example. Make
		sure to use the proper identifier for the method you use, they 
		are not interchangeable.
	 </para>
	 <para>
		There are more sophisticated ways to query Genbank than
		this. This next example attempts to do something "biological",
		using the module 
<ulink url="http://doc.bioperl.org/releases/bioperl-1.4/Bio/DB/Query/Genbank.html">Bio::DB::Query::GenBank</ulink>. Want all Arabidopsis
		topoisomerases from Genbank Nucleotide? This would be a 
		reasonable first attempt:
	 </para>
	  <para>
		<programlisting>
		  use Bio::DB::Query::GenBank;

		  $query = "Arabidopsis[ORGN] AND topoisomerase[TITL]";
		  $query_obj = Bio::DB::Query::GenBank->new(-db    => 'nucleotide',
		                                            -query => $query ); 
		</programlisting>
	 </para>
	 <para>
		That is how we would construct a "query object", but we
		haven't retrieved sequences yet. To do so we will have to create
		a "database object", some object that can get Sequence objects
		for us, just as we did in the first Genbank example:
	 </para>
	  <para>
		<programlisting>
		  use Bio::DB::GenBank;
		  use Bio::DB::Query::GenBank;

		  $query = "Arabidopsis[ORGN] AND topoisomerase[TITL]";
		  $query_obj = Bio::DB::Query::GenBank->new(-db    => 'nucleotide',
		                                            -query => $query ); 

		  $gb_obj = Bio::DB::GenBank->new;
		  $stream_obj = $gb_obj->get_Stream_by_query($query_obj);
		  
		  while ($seq_obj = $stream_obj->next_seq) {
	        # do something with the sequence object
     		  print $seq_obj->display_id, "\t", $seq_obj->length, "\n";
		  }
		</programlisting>
	 </para>
	 <para>
		That <classname>get_Stream_by_query</classname> method and its
		<varname>$stream_obj</varname> may not look familiar. The idea
		is that you will use a stream whenever you expect to retrieve 
		a stream or series of sequence objects. Much like <classname>
		  get_Seq_by_id</classname>, but built to retrieve one or
		more objects, not just one.
	 </para>
	 <para>
		Notice how carefully separated the responsibilities of each
		object are in the code above: an object just to describe the query,
		an object to execute the query using the query object, an object to 
		retrieve, and finally the sequence object.
	 </para>
	 <warning>
		<para>
		  Be careful what you ask for, many of today's nucleotide database
		  entries are genome-size and you will probably run out of memory
		  if your query unintentionally tries to retrieve one of these monstrosities.
		</para>
	 </warning>
	 <para>
		You can find detailed information on Genbank's query fields
		<ulink url="http://www.ncbi.nlm.nih.gov/entrez/query/static/help/Summary_Matrices.html">here</ulink>.
	 </para>
  </section>

  <section id="blast">
    <title>BLAST</title>
    <para>
      <programlisting>
my $seq_in  = Bio::SeqIO->new( -format => 'fasta',
                               -file   => $string);

while( my $seq = $seq_in->next_seq() ) {
  my $factory = Bio::Tools::Run::StandAloneBlast->new(
		  outfile => $seq->display_id . ".blastn",
		  program => 'blastn' );
  my $bl2seq_report = $factory->bl2seq( 'ketosintaza-dna', $seq);
}
      </programlisting>
    </para>
  </section>

  <section id="seq_obj">
    <title>The Sequence object</title>
    <para>
		There's been a lot of discussion around the Sequence object, 
		and we've created this object in a few different ways, but we
		haven't shown what it's capable of doing. The table below
		lists the methods available to you if you have a Sequence
		object in hand. "Returns" means what the object will give
		you if you use or call the method without an argument. The
		same method, such as <function>seq()</function>, can be used to 
		<emphasis>get</emphasis> or <emphasis>set</emphasis> values.
		You're setting when you assign a value, you're
		getting when you ask the object what values it has.
		For example, to <emphasis>get</emphasis> or retrieve a value
    </para>
    <para>
      <programlisting>
		  print $seq_obj->seq;
      </programlisting>
	 </para>
	 <para>
		Or <emphasis>set</emphasis> or assign a value:
	 </para>
	 <para>
		<programlisting>
		  $seq_obj->seq("MMTYDFFFFVVNNNNPPPPAAAW");
      </programlisting>
	 </para>
	 <para>
		<table>
		  <title>Sequence Object Methods</title>
		  <tgroup cols="3">
			 <thead>
				<row>
				  <entry>Name</entry>
				  <entry>Returns</entry>
				  <entry>Example</entry>
				  <entry>Note</entry>
				</row>
			 </thead>
			 <tbody>
				<row>
				  <entry>new</entry>
				  <entry>Sequence object</entry>
				  <entry>$so = Bio::Seq->new(-seq => "at")</entry>
				  <entry>create a new one</entry>
				</row>
				  <entry>seq</entry>
				  <entry>sequence string</entry>
				  <entry>$seq = $so->seq</entry>
				  <entry>get or set the sequence</entry>
				</row>
				<row>
				  <entry>display_id</entry>
				  <entry>identifier</entry>
				  <entry>$so->display_id("#12345")</entry>
				  <entry>get or set an identifier</entry>
				</row>
				<row>
				  <entry>display_name</entry>
				  <entry>name</entry>
				  <entry>$so->display_name("Example 1")</entry>
				  <entry>get or set an identifier</entry>
				</row>
				<row>
				  <entry>primary_id</entry>
				  <entry>identifier</entry>
				  <entry>$so->primary_id(12345)</entry>
				  <entry>get or set an identifier</entry>
				</row>
				<row>
				  <entry>desc</entry>
				  <entry>description</entry>
				  <entry>$so->desc("Example 1")</entry>
				  <entry>get or set a description</entry>
				</row>
				<row>
				  <entry>accession</entry>
				  <entry>identifier</entry>
				  <entry>$so->accession</entry>
				  <entry>get or set an identifier</entry>
				</row>
				<row>
				  <entry>length</entry>
				  <entry>length</entry>
				  <entry>$so->length</entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>alphabet</entry>
				  <entry>alphabet</entry>
				  <entry>$so->alphabet('dna')</entry>
				  <entry>get or set the alphabet ('dna','rna','protein')</entry>
				</row>
				<row>
				  <entry>subseq</entry>
				  <entry>sequence string</entry>
				  <entry>$seq_obj->subseq(10,40)</entry>
				  <entry>Arguments are start and end</entry>
				</row>
				<row>
				  <entry>trunc</entry>
				  <entry>Sequence object</entry>
				  <entry>$so2 = $so1->trunc(10,40)</entry>
				  <entry>truncate, arguments are start and end</entry>
				</row>
				<row>
				  <entry>revcom</entry>
				  <entry>Sequence object</entry>
				  <entry>$so2 = $so1->revcom</entry>
				  <entry>reverse complement</entry>
				</row>
				<row>
				  <entry>translate</entry>
				  <entry>Sequence object</entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>species</entry>
				  <entry>Bio::Species object</entry>
				  <entry>get or set</entry>
				</row>
				<row>
				  <entry>seq_version</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>keywords</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>namespace</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>authority</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>is_circular</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>validate_seq</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
			 </tbody>
		  </tgroup>
      </table>
    </para>
	 <para>
		The table above shows the methods you're likely to use that
		concern the Sequence object directly. There are also a number
		of methods that are concerned the Features and Annotations
		associated with the Sequence object. This is something of a 
		tangent but if you'd like to learn about Features and Annotations
		see the relevant 
<ulink url="http://bioperl.org/HOWTOs/Feature-Annotation/index.html">HOWTO</ulink>.
		The methods related to this topic are shown below.
	 </para>
	 <para>
		<table>
		  <title>Feature and Annotation Methods</title>
		  <tgroup cols="3">
			 <thead>
				<row>
				  <entry>Name</entry>
				  <entry>Returns</entry>
				  <entry>Note</entry>
				</row>
			 </thead>
			 <tbody>
				<row>
				  <entry>get_SeqFeatures</entry>
				  <entry>array of SeqFeature objects</entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>get_all_SeqFeatures</entry>
				  <entry>array of SeqFeature objects</entry>
				  <entry>array includes sub-features</entry>
				</row>
				<row>
				  <entry>remove_SeqFeatures</entry>
				  <entry>array of SeqFeatures removed</entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>feature_count</entry>
				  <entry>number of SeqFeature objects</entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>add_SeqFeature</entry>
				  <entry></entry>
				  <entry></entry>
				</row>
				<row>
				  <entry>annotation</entry>
				  <entry>array of Annotation objects</entry>
				  <entry>get or set</entry>
				</row>
			 </tbody>
		  </tgroup>
      </table>
    </para>

  </section>

<!-- secondary ids? -->

  <section id="examples">
    <title>Example Files</title>
    <para>
		Let's use some of the methods above and see what they return
		when the sequence object is derived from different types of 
		sequnce files.
    </para>
    <para>
    </para>
    <para>
		<emphasis>Fasta file</emphasis>
      <programlisting>
      </programlisting>
    </para>
    <para>
    </para>
    <para>
		<emphasis>Genbank file</emphasis>
      <programlisting>
      </programlisting>
    </para>
    <para>
    </para>
    <para>
		<emphasis>Swissprot file</emphasis>
      <programlisting>
      </programlisting>
    </para>
  </section>

  <section id="regexp">
    <title>Regular Expressions</title>
    <para>
    </para>
    <para>
    </para>
    <para>
    </para>
    <para>
    </para>
  </section>

  <section id="blank2">
    <title></title>
    <para>
	 </para>
    <para>
      <programlisting>
      </programlisting>
    </para>
    <para>
	 </para>
    <para>
      <programlisting>
      </programlisting>
    </para>
    <para>
	 </para>
  </section>
  
  <section id="perldoc">
	 <title>Perl's Documentation System</title>
	 <para>
		Documentation for Perl is written using a system known as POD, which
		stands for "Plain Old Documentation." You can access Perl's built-in
		documentation by using the "perldoc" command. To view information 
		on how to use perldoc, type the following at the command line:
		<programlisting>
		  >perldoc perldoc
		</programlisting>
	 </para>
  
	 <para>
		Bioperl is also documented using POD, and perldoc can be an easy way to
		obtain usage information on any of the Bioperl modules:
		<programlisting>
		  >perldoc Bio::SeqIO
		</programlisting>
	 </para>
  
	 <para>
		Perldoc is a very useful and versatile tool, shown below are some more
		examples on how to use perldoc:
	 </para>
  
	 <para>
		Read about Perl's built-in "print" function:
		<programlisting>
		  >perldoc -f print
		</programlisting>
	 </para>
  </section> 

  <section id="objects">
	 <title>The Basics of Perl Objects</title>
	 <para>
		Object-oriented programming (OOP) is a software engineering
		technique for modularizing code. The difference between
		object-oriented programming and procedural programming can be
		simply illustrated.
	 </para>
	 
	 <para>
		<emphasis>A Simple Example</emphasis>
		Assume that we have a DNA sequence stored in the scalar variable
		$sequence. We'd like to generate the reverse complement of this 
		sequence and store it in $reverse_complement. Shown below is the
		procedural Perl technique of using a subroutine to operate on
		this scalar data:
	 </para>
	 <para>
		Example 1: 
		<programlisting>
		  $reverse_complement = &amp;rev_com( $sequence );
		</programlisting>
	 </para>
	 
	 <para>
		The hallmark of a procedural program is that data and 
		functions to operate on that data are kept separate. In order 
		to generate the reverse
		complement of a DNA sequence, we need to call a function that operates
		on that DNA sequence.
	 </para>
	 
	 <para>
		Shown below is the object-oriented way of generating the reverse 
		complement of a DNA sequence:
	 </para>

	 <para>
		Example 2:
			 <programlisting>
				my $reverse_complement = $sequence->revcom;
			 </programlisting>
		  </para>

		  <para>
			 The main difference between this object-oriented example and the
			 procedural example shown before is that the function for
			 generating the reverse complement (called "revcom") part of
			 $sequence. To put it another way, $sequence knows how to calculate
			 and return its reverse complement. Encapsaluting both data and
			 functions into the same construct is the fundamental idea behind
			 object-oriented programming. 
		  </para>

		  <para>
			 <emphasis>Terminology</emphasis>
                         In the object-oriented example above, $sequence is
                         called an object, and the function "revcom" is called
                         a method.  An <emphasis>object</emphasis> is a data
                         structure that has both data and methods associated
                         with it.  Objects are separated into types called
                         <emphasis>classes</emphasis>, and the class of an
                         object defines both the data that it can hold and the
                         methods that it knows. A specific object that has a
                         defined class is referred to as an
                         <emphasis>instance</emphasis> of that class.
                 </para>

                 <para>
                         <emphasis>Further Reading</emphasis>
                         Bioperl uses the object-oriented paradigm, and readers
                         interested in learning more about object-oriented Perl
                         might find <ulink
                         url="http://www.manning.com/Conway/">Damian Conway's
                         book.</ulink>
                         
                         Anyone who is interested in developing their own
                         modules would do well to read the <ulink
                         url="http://http://bioperl.org/Core/Latest/biodesign.html">Bioperl
                         design documentation</ulink>. 
                </para>
  </section>
</article>

<!--
  <section id="read_seq"> 
     <title>Simple Example: Reading in a Sequence<title>
         <para>
            Shown below is a simple program for reading in a set of biological
            sequences from a file. 
         </para>
         
         <para>
            <programlisting>
               1   #!/usr/bin/perl
               2
               3   use strict;
               4   use Bio::SeqIO;
               5
               6   my $seqio = Bio::SeqIO->new( -file   => 'seq.fasta',
               7                                -format => 'fasta' );
         
            </programlisting>
         </para>

         <para>
            Let's dissect this example line-by-line. Line one defines the path to
            the Perl interpreter (/usr/bin/perl), which is called when the program
            is executed. While not absolutely necessary (especially on a Windows
            machine), it's a good practice to this line to ensure that programs
            will run on a Unix machine. This line is sometimes referred to as the
            "shebang". Line three tells the Perl interpreter to be strict when
            running this program, and to print informative diagnostic messages
            when it encounters a potential error. While not absolutely necessary,
            lines 1-3 are included at the beginning of most Perl programs.
         </para>

         <para>
            Line 4 tells the Perl interpreter to "use the Bio::SeqIO module." While
            this is an over-simplified explanation of what's actually happening,
            it will suffice for now. Lines 6-7 will require a lot of explanation:
            <simplelist type="horiz" columns="1">
               <member>
                  The new method of the Bio::SeqIO module is called. This method
                  is used to construct and return a new Bio::SeqIO object.
               </member>
               <member>
                  This method is passed two arguments: a file value "seq.fasta" and
                  a format value of "fasta". These arguments tell Bio::SeqIO that
                  $seqio will read sequence information from a file named seq.fasta
                  that is stored in the FASTA sequence file format.
               </member>
               <member>
                  The object returned by the "new" method is assigned to the scalar
                  variable $seqio. 
               </member>
               <member>
                  The word "my" tells the Perl interpreter that this is the
                  first time that the variable $seqio has been used, and it
                  also defines the scope of $seqio. Writing "my" before the
                  first use of a variable is a requirement when "using strict."
               </member>
            </simplelist>
               
            The "new" method called in line 6 is called the <emphasis>constructor</emphasis>
            of Bio::SeqIO, as it is used to construct Bio::SeqIO objects.
         </para>

         <para>
            After executing line 7 of the program listed above, Perl has created a Bio::SeqIO
            object named $seqio that will read from a FASTA-formatted file named seq.fasta.
            At this point, the program isn't very impressive, but adding more functionality 
            is not very difficult.
         </para>
    
  </section>

-->

<!--
		<table>
		  <title></title>
		  <tgroup cols="3">
			 <thead>
				<row>
				  <entry></entry>
				  <entry></entry>
				  <entry></entry>
				</row>
			 </thead>
			 <tbody>
				<row>
				  <entry></entry>
				  <entry></entry>
				  <entry></entry>
				</row>
			 </tbody>
		  </tgroup>
      </table>
-->

<!--


	 <para>
		This line does several things:
		<simplelist type="horiz" columns="1">
		  <member>
			 The word "my" tells the Perl interpreter that this is the
			 first time that the variable $seqio has been used, and it
			 also defines the scope of $seqio. Writing "my" before the
			 first use of a variable is a requirement when "using strict."
		  </member>
		  <member>
			 The new method of the Bio::SeqIO module is called. This method
			 is used to construct and return a new Bio::SeqIO object.
		  </member>
		  <member>
			 This method is passed two arguments: a file value "seq.fasta" and
			 a format value of "fasta". These arguments tell Bio::SeqIO that
			 $seqio will read sequence information from a file named seq.fasta
			 that is stored in the FASTA sequence file format.
		  </member>
		  <member>
			 The object returned by the "new" method is assigned to the scalar
			 variable $seqio. 
		  </member>
		</simplelist>
	 </para>
	 
-->
