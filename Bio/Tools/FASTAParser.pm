# You may distribute this module under the same terms as perl itself

=head1 NAME

Bio::FASTAParser - Lightweight FASTA Parser

=head1 SYNOPSIS

 my $report = Bio::Tools::FASTAParser->new(\*STDIN) or die;

 {
 $report->programName;
 $report->version;
 # ......
 $report->histogram;

 while(my $sbjct = $report->nextSbjct) {
     $sbjct->id;
     $sbjct->name;
     # ......
     $sbjct->queryAlign;
     $sbjct->subjectAlign;
     }
 }


OR


 my $report = Bio::Tools::FASTAParser->new(\*STDIN) or die;
 $report->printHeaderInfo;
 $report->printHistogramInfo;
 $report->printStatisticsInfo;
 while (my $this = $report->nextSbjct) {
        $this->printSubjectInfo;
 }


=head1 DESCRIPTION

FASTAParser is a package for parsing FASTA reports. The FASTA programs
(including FASTA, FASTX, FASTY, TFASTX, TFASTY and SSEARCH) are a
family of widely used algorithms for sequence database similarity
searches. There are differences in various versions of FASTA using
various parameters under different operating system and hardware
system.

This parser is far from perfect and I am expecting the users will find
enomous bugs. Anyway, there is no FASTA parser in BioPerl project so I
think it is better to get an imperfect parser than not.

It is written to run standalone (independent of BioPerl). In the
future I can of course integrate it into BioPerl framework if needed.

Do not hesitate to report bugs to me. Alternatively, if you have a
better parser, please upload into repository to override mine.

IMPORTANT NOTICE: currently this module can only analyze FASTA output
generated by redirection (not generated interactively) or using -q
parameter. It can only parse single-threaded FASTA version 3.3 output
under Unix/Linux.

=head2 Object

To create a new report, you pass a filehandle reference to the
FASTAParser constructor.

 my $report = new Bio::Tools::FASTAParser(\*STDIN);

The report has about 25 attributes, and 4 method (nextSbjct).
Some examples:

 $report->query;     # access to the query name
 $report->zTrim;  # gets the zTrim statistical parameter
 $report->lambda; # gets the lambda statistical parameter
 $report->printHeaderInfo; #print all header information (It is not so useful for you)
 while(my $sbjct = $report->nextSbjct) {
     # canonical form of use is in a while loop
 }

A subject is a FASTA hit or a MSP, which should not be confused with
an HSP in BLAST.

Each subject has about 20 attributes and 1 method to print out all
attributes.  Some examples:

 $sbjct->zScore; #gets the z score of one alignment;
 $sbjct->queryAlign;  #gets the alignment sequence of query;

=head1 AUTHORS

Kai Wang (tumorimmunology@yahoo.com, http://www.tumorimmunology.com)

=head1 ACKNOWLEDGEMENTS

The whole program was developed basing on the BPLite.pm of Ian Korf.

=head1 COPYRIGHT

No Rights Reserved. Copy and revise it as you like.

=head1 DISCLAIMER

This software is provided "as is" without warranty of any kind.

=cut

package FASTAParser;
use strict;
1;

###############################################################################
# FASTAParser
###############################################################################
=head2 new

 Title   : new
 Function: Create a new Bio::Tools::FASTAParser object
 Returns : Bio::Tools::FASTAParser object
 Args    : currently you can only use \*STDIN. If in the future this program is viable I will
 consider integrate it into BioPerl and add -file and -fh as arguments.

=cut

sub new {
        my ($class, $fh) = @_;
        if (ref $fh !~ /GLOB/)
                {die "FASTAParser error: new expects a GLOB reference not $fh\n"}
        my $this = bless {};
        $this->{FH} = $fh;
        $this->_parseHeader or $this->throw ("FASTA OUTPUT HEADER ERROR: Please report bug");
        $this->_parseHistogram or $this->throw ("FASTA OUTPUT HISTOGRAM ERROR: Please report bug");
        $this->_parseStatistics or $this->throw ("FASTA OUTPUT STATISTICS ERROR: Please report bug");
        return $this;
}

sub _parseHeader {
        my $this = shift;
        my $fh = $this->{FH};
        while (<$fh>) {
                if (!/\S/) {
                        next;
                } elsif (/^\s(\w*FAST\w+)\s/) {
                        $this->{PROGRAM_NAME} = $1;
                } elsif (/^\sSSEARCH\s/) {
                        $this->{PROGRAM_NAME} = "SSEARCH";
                        $_ = <$fh>;
                } elsif (/^\s+version\s+(\S+)/) {
                        $this->{VERSION} = $1;
                        $1 !~ /^3.3/ and $this->throw ("Current FASTAParser can only parse FASTA3.3 output!");
                } elsif (/^Please cite:$/) {
                        $_ = <$fh>;
                        $this->{PROGRAM_NAME} eq 'SSEARCH' and $_ = <$fh>;
                } elsif (/[:,]\s(\d+)\s(nt|aa)$/) {
                        $this->{QUERY_LENGTH} = $1;
                        chomp ($this->{QUERY} = <$fh>);
                        $_ = <$fh>;
                        /^ vs\s+(\S+)\s+library/ or $this->throw ("_parseHeader cannot parse '$_', please report bug");
                        $this->{LIBRARY} = $1;
                } elsif (/^searching/) {
                        return 1;
                } else {
                        $this->warn ("Unable to parse: $_\nPlease Report Bug!");
                        next;
                }
        }
        return 0;
}


sub _parseHistogram {
        my $this = shift;
        my $fh = $this->{FH};
        while (<$fh>) {
                if (!/\S/) {
                        next;
                } elsif (/^\s+opt\s+E\(\)/) {
                        $this->{SHOW_HISTOGRAM} = 1;
                        while (<$fh>) {
                                $this->{HISTOGRAM} .= $_;
                                /^>/ and last;
                        }
                        return 1;
                } elsif (/^\s+(\d+)\s+residues\s+in\s+(\d+)\s+sequences$/) {
                        $this->{LIBRARY_RESIDUE} = $1;
                        $this->{LIBRARY_SEQUENCE} = $2;
                        $this->{SHOW_HISTOGRAM} = 0;
                        return 1;
                } else {
                        $this->warn ("Unable to parse: $_\nPlease Report Bug");
                        next;
                }
        }
        return 0;
}

sub _parseStatistics {
        my $this = shift;
        my $fh = $this->{FH};
        while (<$fh>) {
                if (!/\S/) {
                        next;
                } elsif (/^\s+(\d+)\s+residues\s+in\s+(\d+)\s+sequences$/) {
                        $this->{LIBRARY_RESIDUE} = $1;
                        $this->{LIBRARY_SEQUENCE} = $2;
                } elsif (/^\s+Expectation_n fit[^=]+=\s*([^;]+);[^=]+=\s*(.+)\n$/) {
                        $this->{EXPECTATION_N} = $1;
                        $this->{MU} = $2;
                } elsif (/^\s+mean_var=([^,]+),[^:]+:\s*(\S+)[^:]+:\s*(\S+)[^:]+:\s*(.+)\n$/) {
                        $this->{MEAN_VAR} = $1;
                        $this->{O_S} = $2;
                        $this->{Z_TRIM} = $3;
                        $this->{B_TRIM} = $4;
                } elsif (/^\s+Lambda=\s*(\S+)\n$/) {
                        $this->{LAMBDA} = $1;
                } elsif (/^\s+Kolmogorov-Smirnov[^:]+:\s*(.+)\n$/) {
                        $this->{KOLMOGOROV_SMIRNOV} = $1;
                } elsif (/matrix \((.+)\).+ktup:\s*(\d)/) {
                        ($this->{MATRIX}, $this->{KTUP}) = ($1, $2);
                } elsif (/matrix \((.*)\).+gap-penalty:\s*(.+)/) {
                        $this->{MATRIX} = $1;
                        $this->{GAP_PENALTY} = $2;
                } elsif (m#\s+join: (\d+). opt: (\d+), gap-pen:\s*([\d-]+/\s*[\d-]+).*width:\s*(\d+)#) {
                        ($this->{JOIN},  $this->{OPT}, $this->{GAP_PENALTY}, $this->{WIDTH}) = ($1, $2, $3, $4);
                        /shift:\s*([\d-]+)/ and  $this->{SHIFT} = $1;
                        /subs:\s*([\d-]+)/ and $this->{SUBS} = $1;
                } elsif (/^\s+Scan time:\s*(\S+)/) {
                        $this->{SCAN_TIME} = $1;
                } elsif (/^>>/) {
                        $this->{LAST_LINE} = $_;
                        $this->{SHOW_ALIGN} = 1;
                        return 1;
                } elsif (/^\d+ residues in \d+ query\s+sequences$/) {
                        $this->{SHOW_ALIGN} = 0;
                        $this->{LAST_LINE} = $_;
                        return 1;
                } elsif (/^The best/ or /\d+$/) {
                        next;
                } else {
                        $this->warn ("Unable to parse: $_\nPlease Report Bug");
                        next;
                }
        }
        return 0;
}
=head2 nextSbjct

 Title    : nextSbjct
 Usage    : $sbjct = $obj->nextSbjct();
 Function : Method of iterating through all the Sbjct retrieved
            from parsing the report
 Example  : while ( my $sbjct = $obj->nextSbjct ) {}
 Returns  : next Sbjct object or 0 if finished
 Args     :

=cut

sub nextSbjct {
        my $this = shift;
        $this->{LAST_LINE} =~ /^>>/ or return 0;
        return FASTAParser::Sbjct::new ($this->{FH}, $this->{LAST_LINE}, $this);
}

sub programName         {shift->{PROGRAM_NAME};}
sub version             {shift->{VERSION};}
sub query               {shift->{QUERY};}
sub queryLength         {shift->{QUERY_LENGTH};}
sub library             {shift->{LIBRARY};}
sub libraryResidue      {shift->{LIBRARY_RESIDUE};}
sub librarySequence     {shift->{LIBRARY_SEQUENCE};}
sub expectationN        {shift->{EXPECTATION_N};}
sub mu                  {shift->{MU};}
sub meanVar             {shift->{MEAN_VAR};}
sub oS                  {shift->{O_S};}
sub zTrim               {shift->{Z_TRIM};}
sub bTrim               {shift->{B_TRIM};}
sub lambda              {shift->{LAMBDA};}
sub kolmogorovSmirnov   {shift->{KOLMOGOROV_SMIRNOV};}
sub kS                  {shift->{KOLMOGOROV_SMIRNOV};}
sub ktup                {shift->{KTUP};}
sub matrix              {shift->{MATRIX};}
sub gapPenalty          {shift->{GAP_PENALTY};}
sub join                {shift->{JOIN};}
sub opt                 {shift->{OPT};}
sub SHIFT               {shift->{SHIFT};}
sub subs                {shift->{SUBS};}
sub scanTime            {shift->{SCAN_TIME};}
sub histogram           {shift->{HISTOGRAM};}


sub printHeaderInfo {
        my $this = shift;
        my @header_info = qw(PROGRAM_NAME VERSION QUERY QUERY_LENGTH LIBRARY);
        foreach (@header_info) {
                exists $this->{$_} and print "$_: ".$this->{$_}."\n";
        }
}

sub printHistogramInfo {
        my $this = shift;
        print "\n-----HISTOGRAM INFORMATION-----\n\n";
        $this->{SHOW_HISTOGRAM} or print "!!!NO HISTOGRAM FOUND!!!\n\n" and return 1;
        print $this->histogram ();
}

sub printStatisticsInfo {
        my $this = shift;
        my @statistics_info = qw(LIBRARY_RESIDUE LIBRARY_SEQUENCE EXPECTATION_N MU MEAN_VAR O_S
                Z_TRIM B_TRIM LAMBDA KOLMOGOROV_SMIRNOV KTUP MATRIX GAP_PENALTY JOIN OPT
                WIDTH SHIFT SUBS SCAN_TIME);
        print "\n-----STATISTICS INFORMATION-----\n\n";
        foreach (@statistics_info) {
                exists $this->{$_} and print "$_: ".$this->{$_}."\n";
        }
}

sub throw{                              #from Bio::Root::RootI
        my ($self,$string) = @_;
        my $std = $self->stack_trace_dump();
        my $out = "-------------------- EXCEPTION --------------------\n"."MSG: ".$string."\n".$std."-------------------------------------------\n";
        die $out;
}

sub stack_trace_dump{                   # from Bio::Root::RootI
        my ($self) = @_;
        my @stack = $self->stack_trace();
        shift @stack; shift @stack; shift @stack;
        my $out;
        my ($module,$function,$file,$position);
        foreach my $stack ( @stack) {
                ($module,$file,$position,$function) = @{$stack};
                $out .= "STACK $function $file:$position\n";
        }
        return $out;
}

sub stack_trace{
   my ($self) = @_;
   my $i = 0;
   my @out;
   my $prev;
   while( my @call = caller($i++)) {
       $prev->[3] = $call[3];
       push(@out,$prev);
       $prev = \@call;
   }
   $prev->[3] = 'toplevel';
   push(@out,$prev);
   return @out;
}

sub warn{                       # from Bio::Root::RootI
        my ($self,$string) = @_;
        my $out = "-------------------- WARNING ---------------------\n"."MSG: ".$string."\n";
        $out .= $self->stack_trace_dump;
        print $out;
        return;
}

###############################################################################
# FASTAParser::Subjct
###############################################################################

package FASTAParser::Sbjct;
use strict;
use FASTAParser;
our @ISA = qw (FASTAParser);
1;

sub new {
        my $this = bless {};
        ($this->{FH}, $this->{LAST_LINE}, $this->{PARENT}) = @_;
        my $fh = $this->{FH};

        chomp ($this->{NAME} = $this->{LAST_LINE});
        /^>>(\S+)/ and $this->{ID} = $1;

        $_ = <$fh>;
        if ($this->{PARENT}->{PROGRAM_NAME} eq "SSEARCH") {
                /opt:\s+(\d+)\s+Z-score:\s+([\d.]+)\s+bits:\s+([\d.]+)\s+E\(\):\s+([\d.e-]+)/ or print "===$_===\n" and die;
                ($this->{OPT}, $this->{Z_SCORE}, $this->{BITS_SCORE}, $this->{E_VALUE}) = ($1, $2, $3, $4);
                /^Frame:\s+(\w)/ and $1 eq "r" and $this->{REV_COMP} = 1;
        } else {
                /^rev-comp/ and $this->{REV_COMP} = 1;
                /^Frame:\s+(\d)/ and $this->{FRAME} = $1 or /^Frame:\s(\w)/ and $1 eq "r" and $this->{REV_COMP} = 1;
                /\s+initn:\s+(\d+)\s+init1:\s+(\d+)\s+opt:\s+(\d+)/ or $this->throw ("Unable to parse:$_\n");
                ($this->{INITN}, $this->{INIT1}, $this->{OPT}) = ($1, $2, $3);
                /\s+Z-score:\s+([\d.]+)\s+bits:\s+([\d.]+)\s+E\(\):\s+([\d.e-]+)/ and ($this->{Z_SCORE}, $this->{BITS_SCORE}, $this->{E_VALUE}) = ($1, $2, $3);
        }

        $_ = <$fh>;
        /Smith-Waterman score:\s*(\d+);/ and $this->{SMITH_WATERMAN_SCORE} = $1;
        /([\d.]+)%\s*identity\s*\(([\d.]+)%.+ in (\d+\s+\w\w).+\((\d+)-(\d+):(\d+)-(\d+)\)$/ or $this->throw ("Unable to Parse:$_\n");
        ($this->{IDENTITY}, $this->{IDENTITY_UNGAPPED}, $this->{OVERLAP}, $this->{QUERY_BEGIN}, $this->{QUERY_END}, $this->{SUBJECT_BEGIN}, $this->{SUBJECT_END}) = ($1, $2, $3, $4, $5, $6, $7);
        defined ($_ = <$fh>) and !/\S/ or $this->throw ("Unable to Parse: $_\n");
        defined ($_ = <$fh>) and /^[\s\d]+$/ or $this->throw ("Unable to Parse: $_\n");
        chomp ($_ = <$fh>);
        /^(\S+)\s+\S+/ or $this->throw ("Unable to Parse: $_\n");
        my ($query_id, $query_align) = ($1, $_);
        $_ = <$fh>;
        /^[\s:.]+$/ or $this->throw ("Unable to Parse: $_\n");
        chomp (my $align_string = $_);
        chomp ($_ = <$fh>);
        /^(\S+)\s+\S+/ or $this->throw ("Unable to Parse: $_\n");
        my ($subject_id, $subject_align) = ($1, $_);

        while (<$fh>) {
                !/\S/ || /^[\d\s]+$/ and next;
                /^>>/ || /^\d+\s+residues\s+in\s+\d+\s+query/ and $this->{PARENT}->{LAST_LINE} = $_ and last;
                /^$query_id\s+(\S+)/ and $query_align .= $1 and next;
                /^$subject_id\s+(\S+)/ and $subject_align .= $1 and next;
                /^\s+(.+)\s+$/ and $align_string .= $1 and next;
                $this->throw ("Unable to Parse: $_\n");
        }

        $align_string =~ s/^(\s*)//;
        substr ($query_align, 0, length ($1)) = "";
        substr ($subject_align, 0, length ($1)) = "";
        $align_string =~ s/\s*$//;
        $query_align = substr ($query_align, 0, length ($align_string));
        $subject_align = substr ($subject_align, 0, length ($align_string));
        ($this->{QUERY_ALIGN}, $this->{ALIGN_STRING}, $this->{SUBJECT_ALIGN}) = ($query_align, $align_string, $subject_align);
        return $this;
}

sub id          {shift->{ID};}
sub name        {shift->{NAME};}
sub frame       {shift->{FRAME};}
sub initn       {shift->{INITN};}
sub init1       {shift->{INIT1};}
sub opt         {shift->{OPT};}
sub zScore      {shift->{Z_SCORE};}
sub bitsScore   {shift->{BITS_SCORE};}
sub smithWatermanScore  {shift->{SMITH_WATERMAN_SCORE};}
sub sws         {shift->{SMITH_WATERMAN_SCORE};}
sub identity    {shift->{IDENTITY};}
sub identityUngappend   {shift->{IDENTITY_UNGAPPED};}
sub overlap     {shift->{OVERLAP};}
sub queryBegin  {shift->{QUERY_BEGIN};}
sub queryEnd    {shift->{QUERY_END};}
sub subjectBegin{shift->{SUBJECT_BEGIN};}
sub subjectEnd  {shift->{SUBJECT_END};}
sub queryAlign  {shift->{QUERY_ALIGN};}
sub alignString {shift->{ALIGN_STRING};}
sub subjectAlign{shift->{SUBJECT_ALIGN};}
sub revComp     {shift->{REV_COMP};}

sub printSubjectInfo {
        my $this = shift;
        my @subject_info = qw(ID REV_COMP NAME FRAME INITN INIT1 OPT Z_SCORE BITS_SCORE E_VALUE SMITH_WATERMAN_SCORE
                IDENTITY IDENTITY_UNGAPPED OVERLAP QUERY_BEGIN QUERY_END SUBJECT_BEGIN SUBJECT_END
                QUERY_ALIGN ALIGN_STRING SUBJECT_ALIGN);
        print "\n=====SUBJECT INFORMATION=====\n";
        foreach (@subject_info) {
                exists $this->{$_} and print "$_: ".$this->{$_}."\n";
        }
}

