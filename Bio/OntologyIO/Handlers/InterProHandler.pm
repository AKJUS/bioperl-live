# $Id$
#
# BioPerl module for InterProHandler
#
# Cared for by Peter Dimitrov <dimitrov@gnf.org>
#
# Copyright Peter Dimitrov
# (c) Peter Dimitrov, dimitrov@gnf.org, 2002.
# (c) GNF, Genomics Institute of the Novartis Research Foundation, 2002.
#
# You may distribute this module under the same terms as perl itself.
# Refer to the Perl Artistic License (see the license accompanying this
# software package, or see http://www.perl.com/language/misc/Artistic.html)
# for the terms under which you may use, modify, and redistribute this module.
#
# THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# POD documentation - main docs before the code

=head1 NAME

InterProHandler - Service class for InterProParser. Handles xml events generated by InterProParser when parsing InterPro xml files.

=head1 SYNOPSIS

Give standard usage here

=head1 DESCRIPTION

Describe the interface here

=head1 FEEDBACK

=head2 Mailing Lists

User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.

bioperl-l@bioperl.org              - General discussion
http://bioperl.org/MailList.shtml  - About the mailing lists

=head2 Reporting Bugs

Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
email or the web:

bioperl-bugs@bioperl.org
http://bioperl.org/bioperl-bugs/

=head1 AUTHOR - Peter Dimitrov

Email dimitrov@gnf.org

Describe contact details here

=head1 CONTRIBUTORS

Additional contributors names and emails here

=head1 APPENDIX

The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

=cut


# Let the code begin...


package Bio::OntologyIO::Handlers::InterProHandler;
use vars qw(@ISA);
use strict;
use Carp;
use Bio::Root::Root;
use Bio::Ontology::RelationshipType;
use Bio::Ontology::InterProTerm;
use Bio::Ontology::SimpleOntologyEngine;
use Bio::Annotation::Reference;
use Data::Dumper;

@ISA = qw(Bio::Root::Root);

my ($record_count, $processed_count, $is_a_rel, $contains_rel, $found_in_rel,
    $family_term, $domain_term, $repeat_term, $ptm_term);

=head2 new

 Title   : new
 Usage   : $h = Bio::OntologyIO::Handlers::InterProHandler->new;
 Function: Initializes global variables
 Example :
 Returns : an InterProHandler object
 Args    :


=cut

sub new{
  my ($class, @args) = @_;
  my $self = $class->SUPER::new(@args);

  $is_a_rel = Bio::Ontology::RelationshipType->get_instance( "IS_A" );
  $contains_rel = Bio::Ontology::RelationshipType->get_instance( "CONTAINS" );
  $found_in_rel = Bio::Ontology::RelationshipType->get_instance( "FOUND_IN" );
  $self->_cite_skip(0);

  return $self;
}

=head2 ontology_engine

 Title   : ontology_engine
 Usage   : $obj->ontology_engine($newval)
 Function: Get/set ontology engine. Can be initialized only once.
 Example : 
 Returns : value of ontology_engine (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub ontology_engine{
  my ($self, $value) = @_;

  if( defined $value) {
    if ( defined $self->{'ontology_engine'}) {
      $self->throw("ontology_engine already defined");
    }
    else {
      $self->{'ontology_engine'} = $value;
      $self->debug("Registering ontology engine (".ref($value)."):\n".
		   $value->to_string."\n");
    }
  }

  return $self->{'ontology_engine'};
}

=head2 _cite_skip

 Title   : _cite_skip
 Usage   : $obj->_cite_skip($newval)
 Function: 
 Example : 
 Returns : value of _cite_skip (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _cite_skip{
  my ($self, $value) = @_;

  if( defined $value) {
    $self->{'_cite_skip'} = $value;
  }

  return $self->{'_cite_skip'};
}

=head2 _hash

 Title   : _hash
 Usage   : $obj->_hash($newval)
 Function: 
 Example : 
 Returns : value of _hash (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _hash{
  my ($self, $value) = @_;

  if( defined $value) {
    $self->{'_hash'} = $value;
  }

  return $self->{'_hash'};
}

=head2 _stack

 Title   : _stack
 Usage   : $obj->_stack($newval)
 Function: 
 Example : 
 Returns : value of _stack (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _stack{
  my ($self, $value) = @_;

  if( defined $value) {
    $self->{'_stack'} = $value;
  }
  return $self->{'_stack'};
}

=head2 _top

 Title   : _top
 Usage   :
 Function:
 Example :
 Returns : 
 Args    :


=cut

sub _top{
  my ($self, $_stack) = @_;
  my @stack = @{$_stack};

  return $stack[@stack - 1];
}

=head2 _term

 Title   : _term
 Usage   : $obj->_term($newval)
 Function: Get/set method for the term currently processed.
 Example : 
 Returns : value of term (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _term{
  my ($self, $value) = @_;

  if(defined $value) {
    $self->{'_term'} = $value;
  }

  return $self->{'_term'};
}

=head2 _clear_term

 Title   : _clear_term
 Usage   :
 Function:
 Example :
 Returns : 
 Args    :


=cut

sub _clear_term{
  my ($self) = @_;

  delete $self->{'_term'};
}

=head2 _names

 Title   : _names
 Usage   : $obj->_names($newval)
 Function: 
 Example : 
 Returns : value of _names (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _names{
  my ($self, $value) = @_;

  if( defined $value) {
    $self->{'_names'} = $value;
  }

  return $self->{'_names'};
}

=head2 _create_relationship

 Title   : _create_relationship
 Usage   :
 Function:
 Example :
 Returns : 
 Args    :


=cut

sub _create_relationship{
  my ($self, $ref_id, $rel_type_term) = @_;
  my $ont_eng = $self->ontology_engine;
  my $term_temp = ($ont_eng->get_term_by_identifier($ref_id))[0];
  my $rel = Bio::Ontology::Relationship->new( -relationship_type => $rel_type_term );
	
  if (!defined $term_temp) {
    $term_temp = $ont_eng->add_term( Bio::Ontology::InterProTerm->new( -InterPro_id => $ref_id ) );
    $ont_eng->mark_uninstantiated($term_temp);
  }
  if ($self->_top($self->_names) eq 'parent_list') {
    $rel->parent_term( $term_temp );
    $rel->child_term( $self->_term );
  } else {
    $rel->parent_term( $self->_term );
    $rel->child_term( $term_temp );
  }
  $ont_eng->add_relationship($rel);
}

=head2 start_element

 Title   : start_element
 Usage   :
 Function: This is a method that is derived from XML::SAX::Base and has to be overridden for processing start of xml element events. Used internally only.
 Example :
 Returns : 
 Args    :


=cut

sub start_element {
  my ($self, $element) = @_;
  my $ont_eng = $self->ontology_engine;

  if ($element->{Name} eq 'interprodb') {
    $family_term = Bio::Ontology::Term->new( -identifier => "Family",
					     -name => "Family");
    $ont_eng->add_term($family_term);
    $domain_term = Bio::Ontology::Term->new( -identifier => "Domain",
					     -name => "Domain");
    $ont_eng->add_term($domain_term);
    $repeat_term = Bio::Ontology::Term->new( -identifier => "Repeat",
					     -name => "Repeat");
    $ont_eng->add_term($repeat_term);
    $ptm_term = Bio::Ontology::Term->new( -identifier => "PTM",
					  -name => "PTM");
    $ont_eng->add_term($ptm_term);
  } elsif ($element->{Name} eq 'interpro') {
    my %record_args = %{$element->{Attributes}};
    my $id = $record_args{"id"};
    my $term_temp = ($ont_eng->get_term_by_identifier($id))[0];

    $self->_term(
		 (!defined $term_temp)
		 ? $ont_eng->add_term( Bio::Ontology::InterProTerm->new( -InterPro_id => $id ) )
		 : $term_temp
		);

    $self->_term->category( $record_args{"type"} );
    $self->_term->short_name( $record_args{"short_name"} );
    $self->_term->protein_count( $record_args{"protein_count"} );
    $self->_increment_record_count();
    $self->_stack([{ interpro => undef }]);
    $self->_names(["interpro"]);

    ## Adding a relationship between the newly created InterPro term
    ## and the term describing its type

    my $rel = Bio::Ontology::Relationship->new( -relationship_type => $is_a_rel );
    $rel->parent_term( ($ont_eng->get_term_by_identifier($record_args{"type"}))[0] );
    $rel->child_term( $self->_term );
    $ont_eng->add_relationship($rel);
  }
  elsif (defined $self->_stack) {
    my %hash = ();

    if (keys %{$element->{Attributes}} > 0) {
      foreach my $key (keys %{$element->{Attributes}}) {
	$hash{$key} = $element->{Attributes}->{$key};
      }
    }
    push @{$self->_stack}, \%hash;
    if ($element->{Name} eq 'rel_ref') {
      my $ref_id = $element->{Attributes}->{"ipr_ref"};
      my $parent = $self->_top($self->_names);

      if ($parent eq 'parent_list' || $parent eq 'child_list') {
	$self->_create_relationship($ref_id, $is_a_rel);
      }
      if ($parent eq 'contains' ) {
	$self->_create_relationship($ref_id, $contains_rel);
      }
      if ($parent eq 'found_in' ) {
	$self->_create_relationship($ref_id, $found_in_rel);
      }
    }
    elsif ($element->{Name} eq 'abstract') {
      $self->_cite_skip(1);
    }
    push @{$self->_names}, $element->{Name};
  }

}

=head2 _char_storage

 Title   : _char_storage
 Usage   : $obj->_char_storage($newval)
 Function: 
 Example : 
 Returns : value of _char_storage (a scalar)
 Args    : new value (a scalar, optional)


=cut

sub _char_storage{
  my ($self, $value) = @_;

  if( defined $value) {
    $self->{'_char_storage'} = $value;
  }

  return $self->{'_char_storage'};
}

=head2 characters

 Title   : characters
 Usage   :
 Function: This is a method that is derived from XML::SAX::Base and has to be overridden for processing xml characters events. Used internally only.
 Example :
 Returns : 
 Args    :


=cut

sub characters {
  my ($self, $characters) = @_;
  my $text = $characters->{Data};

  chomp $text;
  $text =~ s/^(\s+)//;
  $self->{_char_storage} .= $text;

}

=head2 end_element

 Title   : end_element
 Usage   :
 Function: This is a method that is derived from XML::SAX::Base and has to be overridden for processing end of xml element events. Used internally only.
 Example :
 Returns : 
 Args    :


=cut

sub end_element {
  my ($self, $element) = @_;

  if ($element->{Name} eq 'interprodb') {
    $self->debug("Interpro DB Parser Finished: $record_count read, $processed_count processed\n");
  }
  elsif ($element->{Name} eq 'interpro') {
    $self->_clear_term;
    $self->_increment_processed_count();
  }
  elsif ($element->{Name} ne 'cite') {
    $self->{_char_storage} =~ s/<\/?p>//g;
    if ((defined $self->_stack)) {
      my $current_hash = pop @{$self->_stack};
      my $parent_hash = $self->_top($self->_stack);
      my $current_hash_key = pop @{$self->_names};

      if (keys %{$current_hash} > 0 && $self->_char_storage ne "") {
	$current_hash->{comment} = $self->_char_storage;
	push @{ $parent_hash->{$current_hash_key} }, $current_hash
      }
      elsif ($self->_char_storage ne ""){
	push @{ $parent_hash->{$current_hash_key} }, { 'accumulated_text_12345' => $self->_char_storage };
      }
      elsif (keys %{$current_hash} > 0) {
	push @{ $parent_hash->{$current_hash_key} }, $current_hash;
      }
      if ($element->{Name} eq 'pub_list') {
	my @refs = ();

	foreach my $pub_record ( @{ $current_hash->{publication} } ) {
	  my $ref = Bio::Annotation::Reference->new;
	  my $loc = $pub_record->{location}->[0];

	  $ref->location( $pub_record->{journal}->[0]->{accumulated_text_12345}.", ".$loc->{firstpage}."-".$loc->{lastpage}.", ".$loc->{volume}.", ".$pub_record->{year}->[0]->{accumulated_text_12345});
	  $ref->title( $pub_record->{title}->[0]->{accumulated_text_12345} );
	  my $ttt = $pub_record->{author_list}->[0];

	  $ref->authors( $ttt->{accumulated_text_12345} );
	  $ref->medline( scalar($ttt->{dbkey}) ) if $ttt->{db} eq "MEDLINE";
	  push @refs, $ref;
	}
 	$self->_term->references(\@refs);
      }
      elsif ($element->{Name} eq 'name') {
 	$self->_term->name( $self->_char_storage );
      }
      elsif ($element->{Name} eq 'abstract') {
	$self->_term->definition( $self->_char_storage );
	$self->_cite_skip(0);
      }
      elsif ($element->{Name} eq 'member_list') {
	my @refs = ();

	foreach my $db_xref ( @{ $current_hash->{db_xref} } ) {
	  push @refs, Bio::Annotation::DBLink->new( -database => $db_xref->{db},
						    -primary_id => $db_xref->{dbkey}
						  );
	}
 	$self->_term->member_list(\@refs);
      }
      elsif ($element->{Name} eq 'sec_list') {
	my @refs = ();

	foreach my $sec_ac ( @{ $current_hash->{sec_ac} } ) {
	  push @refs, $sec_ac->{sec_ac};
	}
 	$self->_term->member_list(\@refs);
      }
      elsif ($element->{Name} eq 'example_list') {
	my @refs = ();

	foreach my $example ( @{ $current_hash->{example} } ) {
	  push @refs, Bio::Annotation::DBLink->new( -database => $example->{db_xref}->[0]->{db},
						    -primary_id => $example->{db_xref}->[0]->{dbkey},
						    -comment => $example->{comment}
						  );
	}
 	$self->_term->examples(\@refs);
      }
      elsif ($element->{Name} eq 'external_doc_list') {
	my @refs = ();

	foreach my $db_xref ( @{ $current_hash->{db_xref} } ) {
	  push @refs, Bio::Annotation::DBLink->new( -database => $db_xref->{db},
						    -primary_id => $db_xref->{dbkey}
						  );
	}
 	$self->_term->external_doc_list(\@refs);
      }
      elsif ($element->{Name} eq 'class_list') {
	my @refs = ();

	foreach my $classification ( @{ $current_hash->{classification} } ) {
	  push @refs, Bio::Annotation::DBLink->new( -database => $classification->{class_type},
						    -primary_id => $classification->{id}
						  );
	}
 	$self->_term->class_list(\@refs);
      }
      elsif ($element->{Name} eq 'deleted_entries') {
	my @refs = ();

	foreach my $del_ref ( @{ $current_hash->{del_ref} } ) {
	  my $term = ($self->ontology_engine->get_term_by_identifier( $del_ref->{id} ))[0];

	  $term->is_obsolete(1) if defined $term;
	}
      }
    }
    $self->_char_storage( '' ) if !$self->_cite_skip;
  }
}

=head2 _increment_record_count

 Title   : _increment_record_count
 Usage   :
 Function:
 Example :
 Returns : 
 Args    :


=cut

sub _increment_record_count{
  $record_count++;
}

=head2 _increment_processed_count

 Title   : _increment_processed_count
 Usage   :
 Function:
 Example :
 Returns : 
 Args    :


=cut

sub _increment_processed_count{
  $processed_count++;
  print $processed_count."\n" if $processed_count % 100 == 0;
}

1;
